#!/bin/bash

# Elle sera utilisée à chaque fois qu'on aura un message d'erreur
function message_erreur_exit(){
    echo "$1" >&2
    exit $2
}

# Fonction trouver sur reddit
# -A pour tableau associatif
declare -A convertion_nombre=(
    [one]=o1e
    [two]=t2o
    [three]=t3e
    [four]=f4r
    [five]=f5e
    [six]=s6x
    [seven]=s7n
    [eight]=e8t
    [nine]=n9n
)

# Fonction trouver sur reddit
function replace_mot_chiffre() {
	# Pour chaque motif de la liste, on va essayer de le trouver sur la ligne et le remplacer
	# ${!convertion_nombre[@]}" -> affiche la key de la liste
	# ${convertion_nombre[@]}" -> affiche la value de la liste
    for value in "${!convertion_nombre[@]}"; do
    	# Dans la ligne, on trouve la value et on la converti
    	if [[ "$ligne" =~ $value ]]; then
    		# variable="${variable//pattern/replacement}"
    		# // remplace toutes les occurences
    		ligne="${ligne//$value/${convertion_nombre[$value]}}"
    		# Les accolades {} sont utilisées pour délimiter la variable à l'intérieur de la chaîne.
    	fi
    done
}
###################################################################
 # Début de l'exécution du script

 # Si le nombre d'arguments est en bas de 2 ou supérieur à 5, Exit 1
if [ $# -ne 1 ]; then
	message_erreur_exit "Veuiller fournir le fichier pour les tests !" 1
fi

 # On récupère le fichier
 fichier="$1"

 # On valide si nous avons un fichier
if [ ! -f "$fichier" ]; then
	message_erreur_exit "Le fichier « $fichier » est soit invalide ou non trouvé..." 1
fi

somme_total=0
while read ligne; do

	# On doit convertir tous les mot en chiffre, s'il y a lieu
	replace_mot_chiffre
	# Ça garde seulement les chiffres sur plusieurs lignes
	tous_chiffres=$(echo "$ligne" | grep -o '[0-9]')
	nb_chiffres=$(echo "$ligne" | grep -o '[0-9]' | wc -l)

	# À tous les coups, il y aura 1 chiffre au moins
	premier=$(echo "$tous_chiffres" | head -n 1)

	if [ "$nb_chiffres" -ge 2 ]; then
		# On extraire dernier chiffre pour les deux situations
		# Soit si nous avons un nombre entre 10 et 99 OU 100 et +, ça revient au même
		dernier=$(echo "$tous_chiffres" | tail -n 1)
		somme_total=$((somme_total + (premier * 10) + dernier))
	# Nous avons alors un nombre à un digit, donc on doit le multiplier
	else
        somme_total=$((somme_total + (tous_chiffres * 11) ))
	fi
    # < On injecte dans l'entrée standard du while, le fichier au complèt pour lire
done < "$fichier"

echo "$somme_total"