#!/bin/bash

# Elle sera utilisée à chaque fois qu'on aura un message d'erreur
function message_erreur_exit(){
    echo "$1" >&2
    exit $2
}
###################################################################
 # Début de l'exécution du script

 # Si le nombre d'arguments est en bas de 2 ou supérieur à 5, Exit 1
if [ $# -ne 1 ]; then
	message_erreur_exit "Veuiller fournir le fichier pour les tests !" 1
fi

 # On récupère le fichier
 fichier="$1"

 # On valide si nous avons un fichier
if [ ! -f "$fichier" ]; then
	message_erreur_exit "Le fichier « $fichier » est soit invalide ou non trouvé..." 1
fi

somme_total=0
while IFS= read -r ligne; do
	# Ça garde seulement les chiffres et élimine les \n
	tous_chiffres=$(echo "$ligne" | grep -o '[0-9]')
	nb_chiffres=$(echo "$ligne" | grep -o '[0-9]' | wc -l)

	# 100 et plus, on doit retirer les chiffres du milieu
	if [ "$nb_chiffres" -ge 3 ]; then
		# On extraire le premier et dernier chiffre
		premier=$(echo "$tous_chiffres" | head -n 1)
		dernier=$(echo "$tous_chiffres" | tail -n 1)
		echo "$premier $dernier"
		somme_total=$((somme_total + (premier * 10) + dernier))
	# 0 et 9 -> on doit multiplier par 11
	elif [ "$nb_chiffres" -eq 1 ]; then
		echo "$tous_chiffres"
		# On doit multiplier par 11 pour doubler le chiffre
		somme_total=$((somme_total + (tous_chiffres * 11) ))
	# 10 et 99 -> on additionne directement
	else
		premier=$(echo "$tous_chiffres" | head -n 1)
        deuxieme=$(echo "$tous_chiffres" | tail -n 1)
        echo "$premier $deuxieme"
		somme_total=$((somme_total + (premier * 10) + deuxieme))
	fi
    # < On injecte dans l'entrée standard du while, le fichier au complèt pour lire
done < "$fichier"

echo "$somme_total"