#!/bin/bash

# Elle sera utilisée à chaque fois qu'on aura un message d'erreur
function message_erreur_exit(){
    echo "$1" >&2
    exit $2
}
###################################################################
 # Début de l'exécution du script

 # Si le nombre d'arguments est en bas de 2 ou supérieur à 5, Exit 1
if [ $# -ne 1 ]; then
	message_erreur_exit "Veuiller fournir le fichier pour les tests !" 1
fi

 # On récupère le fichier
 fichier="$1"

 # On valide si nous avons un fichier
if [ ! -f "$fichier" ]; then
	message_erreur_exit "Le fichier « $fichier » est soit invalide ou non trouvé..." 1
fi

somme_total=0
while read ligne; do
	# Ça garde seulement les chiffres et élimine les \n
	tous_chiffres=$(echo "$ligne" | grep -o '[0-9]' | tr -d '\n')

	# 100 et plus, on doit retirer les chiffres du milieu
	if [ "$tous_chiffres" -gt 99 ]; then
		# On extraire le premier et dernier chiffre
		premier=$(echo "$tous_chiffres" | cut -c 1)
		dernier=$(echo "$tous_chiffres" | cut -c -1)
		echo "$premier$dernier"
		somme_total=$((somme_total + (premier * 10) + dernier))
	# 0 et 9 -> on doit multiplier par 11
	elif [ "$tous_chiffres" -lt 10 ]; then
		echo "$tous_chiffres"
		# On doit multiplier par 11 pour doubler le chiffre
		somme_total=$((somme_total + (tous_chiffres * 11) ))
	# 10 et 99 -> on additionne directement
	else
		echo "$tous_chiffres"
		somme_total=$((somme_total + tous_chiffres))
	fi
    # < On injecte dans l'entrée standard du while, le fichier au complèt pour lire
done < "$fichier"

#echo "$somme_total"