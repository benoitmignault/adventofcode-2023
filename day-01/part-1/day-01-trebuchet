#!/bin/bash

# Elle sera utilisée à chaque fois qu'on aura un message d'erreur
function message_erreur_exit(){
    echo "$1" >&2
    exit $2
}
###################################################################
 # Début de l'exécution du script

 # Si le nombre d'arguments est en bas de 2 ou supérieur à 5, Exit 1
if [ $# -ne 1 ]; then
	message_erreur_exit "Veuiller fournir le fichier pour les tests !" 1
fi

 # On récupère le fichier
 fichier="$1"

 # On valide si nous avons un fichier
if [ ! -f "$fichier" ]; then
	message_erreur_exit "Le fichier « $fichier » est soit invalide ou non trouvé..." 1
fi

somme_total=0
while read ligne; do
	# Ça garde seulement les chiffres sur plusieurs lignes
	tous_chiffres=$(echo "$ligne" | grep -o '[0-9]')
	nb_chiffres=$(echo "$ligne" | grep -o '[0-9]' | wc -l)

	# À tous les coups, il y aura 1 chiffre au moins
	premier=$(echo "$tous_chiffres" | head -n 1)

	if [ "$nb_chiffres" -ge 2 ]; then
		# On extraire dernier chiffre pour les deux situations
		# Soit si nous avons un nombre entre 10 et 99 OU 100 et +, ça revient au même
		dernier=$(echo "$tous_chiffres" | tail -n 1)
		somme_total=$((somme_total + (premier * 10) + dernier))
	# Nous avons alors un nombre à un digit, donc on doit le multiplier
	else
        somme_total=$((somme_total + (tous_chiffres * 11) ))
	fi
    # < On injecte dans l'entrée standard du while, le fichier au complèt pour lire
done < "$fichier"

echo "$somme_total"